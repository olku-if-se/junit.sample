/* Prepare for Offline Mode */
def localRepoPath = System.getenv('LOCAL_M2_REPO') ?: "${rootDir}${File.separator}repository"

// This mapping defines the output dir of Maven artifacts (group/artifact/version layout)
def getMavenArtifactPath(String group, String artifact, String version) {
    def localRepoPath = System.getenv('LOCAL_M2_REPO') ?: "${rootDir}/repository"
    return file("${localRepoPath}/${group.replace('.', '/')}/${artifact}/${version}")
}

// Task to copy dependencies from Gradle cache to local Maven repo dir
tasks.register("offlineRepository") {
    group = "dependency management"
    description = "Resolve and copy all dependencies into local Maven repo"

    doLast {
        def localRepoDir = file(localRepoPath)
        if (!localRepoDir.exists() && !localRepoDir.mkdirs()) {
            throw new GradleException("Failed to create local Maven repository directory: $localRepoPath")
        }
        logger.lifecycle "üîÑ Starting offline repository preparation at: $localRepoPath"
        
        // Log what we're about to process
        logger.lifecycle "üìã DIAGNOSIS: Identifying missing dependency types..."
        logger.lifecycle "   ‚úì Project configurations: ${configurations.findAll { it.canBeResolved }.size()} found"
        logger.lifecycle "   ‚úó Plugin dependencies: NOT CURRENTLY PROCESSED"
        logger.lifecycle "   ‚úó buildSrc dependencies: NOT CURRENTLY PROCESSED"
        logger.lifecycle "   ‚úó Parent POM resolution: NOT CURRENTLY PROCESSED"
        logger.lifecycle ""

        // Create a separate repository configuration for artifact resolution
        // This ensures we check remote repositories for sources/javadoc even if main JAR exists locally
        def remoteRepos = project.repositories.matching { repo ->
            repo.name != 'maven' || !repo.url.toString().contains('repository')
        }

        logger.lifecycle "üîç PHASE 1: Processing project configurations..."
        def processedArtifacts = 0
        def foundParentPoms = []
        
        configurations.findAll { it.canBeResolved }.each { configuration ->
            logger.lifecycle "üìÅ Resolving configuration: ${configuration.name}"
            try {
                configuration.resolve()

                configuration.resolvedConfiguration.resolvedArtifacts.each { artifact ->
                    processedArtifacts++
                    def group = artifact.moduleVersion.id.group
                    def name = artifact.name
                    def version = artifact.moduleVersion.id.version
                    def classifier = artifact.classifier ? "-${artifact.classifier}" : ""
                    def artifactDir = getMavenArtifactPath(group, name, version)

                    if (!artifactDir.exists() && !artifactDir.mkdirs()) {
                        throw new GradleException("Failed to create directory: $artifactDir")
                    }

                    // Copy main artifact
                    def artifactFile = artifact.file
                    def targetFileName = "${name}-${version}${classifier}.${artifact.extension}"
                    def targetFile = new File(artifactDir, targetFileName)
                    if (!targetFile.exists()) {
                        logger.info "Copying artifact $artifactFile to $targetFile"
                        project.copy {
                            from artifactFile
                            into artifactDir
                        }
                        if (!targetFile.exists() || targetFile.length() == 0) {
                            throw new GradleException("Failed to copy artifact to $targetFile")
                        }
                    }

                    // Only resolve additional artifacts for non-manifold dependencies to prevent cross-contamination
                    if (!group.startsWith('systems.manifold')) {
                        def pomParents = resolveAndCopyAdditionalArtifacts(group, name, version, artifactDir)
                        if (pomParents) {
                            foundParentPoms.addAll(pomParents)
                        }
                    } else {
                        // For manifold artifacts, only try to get the POM for parent reference extraction
                        try {
                            def depConf = configurations.detachedConfiguration()
                            depConf.transitive = false
                            def dependency = dependencies.create("${group}:${name}:${version}@pom")
                            depConf.dependencies.add(dependency)
                            depConf.resolve().each { file ->
                                def target = new File(artifactDir, file.name)
                                if (!target.exists()) {
                                    project.copy {
                                        from file
                                        into artifactDir
                                    }
                                    def parentRef = extractParentPomReference(target)
                                    if (parentRef) {
                                        foundParentPoms.add(parentRef)
                                        logger.lifecycle "üîç Found parent POM reference: ${parentRef}"
                                    }
                                }
                            }
                        } catch (Exception e) {
                            logger.warn "Could not resolve POM for ${group}:${name}:${version}: ${e.message}"
                        }
                    }
                }
            } catch (Exception e) {
                logger.warn "Warning: Could not resolve configuration ${configuration.name}: ${e.message}"
            }
        }
        
        logger.lifecycle "üìä PHASE 1 COMPLETE: Processed ${processedArtifacts} artifacts from project configurations"
        logger.lifecycle "‚ö†Ô∏è  Found ${foundParentPoms.size()} parent POMs that need resolution from new downloads:"
        foundParentPoms.unique().each { parent ->
            logger.lifecycle "   - ${parent}"
        }
        
        // PHASE 2: Process buildscript and plugin dependencies
        logger.lifecycle ""
        logger.lifecycle "üîç PHASE 2: Processing buildscript and plugin dependencies..."
        def pluginArtifacts = processPluginDependencies()
        
        // PHASE 3: Process buildSrc dependencies
        logger.lifecycle ""
        logger.lifecycle "üîç PHASE 3: Processing buildSrc dependencies..."
        def buildSrcArtifacts = processBuildSrcDependencies()
        
        // PHASE 4: Recursive parent POM resolution
        logger.lifecycle ""
        logger.lifecycle "üîç PHASE 4: Resolving parent POMs recursively..."
        def resolvedParents = resolveParentPomsRecursively()
        
        // PHASE 5: Resolve known plugin runtime dependencies
        logger.lifecycle ""
        logger.lifecycle "üîç PHASE 5: Resolving known plugin runtime dependencies..."
        def pluginRuntimeArtifacts = resolvePluginRuntimeDependencies()
        
        logger.lifecycle ""
        logger.lifecycle "‚úÖ COMPLETE: Offline repository preparation finished!"
        logger.lifecycle "üìä SUMMARY:"
        logger.lifecycle "   - Project artifacts: ${processedArtifacts}"
        logger.lifecycle "   - Plugin artifacts: ${pluginArtifacts}"
        logger.lifecycle "   - buildSrc artifacts: ${buildSrcArtifacts}"
        logger.lifecycle "   - Parent POMs resolved: ${resolvedParents}"
        logger.lifecycle "   - Plugin runtime deps: ${pluginRuntimeArtifacts}"
        logger.lifecycle "   - Total: ${processedArtifacts + pluginArtifacts + buildSrcArtifacts + resolvedParents + pluginRuntimeArtifacts}"
    }
}

// Helper method to resolve additional artifacts (POM, sources, javadoc) with remote-first strategy
def resolveAndCopyAdditionalArtifacts(String group, String name, String version, File artifactDir) {
    def foundParentPoms = []
    
    // Strategy 1: Try individual artifact resolution with remote repositories
    ['@pom', ':sources@jar', ':javadoc@jar'].each { classifier ->
        try {
            def depConf = configurations.detachedConfiguration()
            // Prevent transitive dependency resolution to avoid cross-contamination
            depConf.transitive = false
            
            def dependency = dependencies.create("${group}:${name}:${version}${classifier}")
            depConf.dependencies.add(dependency)

            depConf.resolve().each { file ->
                def target = new File(artifactDir, file.name)
                if (!target.exists()) {
                    logger.info "Copying additional artifact: $file to $target"
                    project.copy {
                        from file
                        into artifactDir
                    }
                    if (!target.exists() || target.length() == 0) {
                        logger.warn "Failed to copy $file to $target"
                    } else {
                        logger.info "Successfully copied ${file.name} (${target.length()} bytes)"
                        
                        // Check for parent POM references in downloaded POM files
                        if (classifier == '@pom' && file.name.endsWith('.pom')) {
                            def parentRef = extractParentPomReference(file)
                            if (parentRef) {
                                foundParentPoms.add(parentRef)
                                logger.lifecycle "üîç Found parent POM reference: ${parentRef}"
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            logger.warn "Could not resolve ${group}:${name}:${version}${classifier}: ${e.message}"
        }
    }

    // Strategy 2: Try Gradle's variant-aware resolution for sources and javadoc
    resolveVariantArtifacts(group, name, version, artifactDir, 'sources')
    resolveVariantArtifacts(group, name, version, artifactDir, 'javadoc')
    
    return foundParentPoms
}

// Helper method to extract parent POM reference from a POM file
def extractParentPomReference(File pomFile) {
    try {
        def pomText = pomFile.text
        def parentMatch = pomText =~ /<parent>\s*<groupId>(.*?)<\/groupId>\s*<artifactId>(.*?)<\/artifactId>\s*<version>(.*?)<\/version>/
        if (parentMatch.find()) {
            return "${parentMatch.group(1)}:${parentMatch.group(2)}:${parentMatch.group(3)}"
        }
    } catch (Exception e) {
        logger.debug "Could not parse POM file ${pomFile.name}: ${e.message}"
    }
    return null
}

// Process plugin dependencies (buildscript classpath)
def processPluginDependencies() {
    def pluginArtifacts = 0
    
    try {
        // Process buildscript dependencies
        def buildscriptClasspath = project.buildscript.configurations.classpath
        logger.lifecycle "üì¶ Processing buildscript classpath..."
        
        buildscriptClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            def group = artifact.moduleVersion.id.group
            def name = artifact.name
            def version = artifact.moduleVersion.id.version
            def classifier = artifact.classifier ? "-${artifact.classifier}" : ""
            def artifactDir = getMavenArtifactPath(group, name, version)

            if (!artifactDir.exists() && !artifactDir.mkdirs()) {
                throw new GradleException("Failed to create directory: $artifactDir")
            }

            // Copy main artifact
            def artifactFile = artifact.file
            def targetFileName = "${name}-${version}${classifier}.${artifact.extension}"
            def targetFile = new File(artifactDir, targetFileName)
            if (!targetFile.exists()) {
                logger.lifecycle "üì¶ Copying buildscript artifact: ${group}:${name}:${version}"
                project.copy {
                    from artifactFile
                    into artifactDir
                }
                pluginArtifacts++
                
                // Copy additional artifacts (POM, sources, javadoc)
                resolveAndCopyAdditionalArtifacts(group, name, version, artifactDir)
            }
        }
        
    } catch (Exception e) {
        logger.warn "Warning: Could not process plugin dependencies: ${e.message}"
    }
    
    return pluginArtifacts
}

// Process buildSrc dependencies
def processBuildSrcDependencies() {
    def buildSrcArtifacts = 0
    
    try {
        def buildSrcDir = file("${rootDir}/buildSrc")
        if (!buildSrcDir.exists()) {
            logger.lifecycle "üì¶ No buildSrc directory found, skipping..."
            return 0
        }
        
        logger.lifecycle "üì¶ Processing buildSrc dependencies..."
        
        // Execute gradle dependencies command on buildSrc to get its resolved dependencies
        def buildSrcProject = project(':buildSrc')
        if (buildSrcProject != null) {
            buildSrcProject.configurations.findAll { it.canBeResolved }.each { configuration ->
                logger.lifecycle "üìÅ Processing buildSrc configuration: ${configuration.name}"
                try {
                    configuration.resolvedConfiguration.resolvedArtifacts.each { artifact ->
                        def group = artifact.moduleVersion.id.group
                        def name = artifact.name
                        def version = artifact.moduleVersion.id.version
                        def classifier = artifact.classifier ? "-${artifact.classifier}" : ""
                        def artifactDir = getMavenArtifactPath(group, name, version)

                        if (!artifactDir.exists() && !artifactDir.mkdirs()) {
                            throw new GradleException("Failed to create directory: $artifactDir")
                        }

                        // Copy main artifact
                        def artifactFile = artifact.file
                        def targetFileName = "${name}-${version}${classifier}.${artifact.extension}"
                        def targetFile = new File(artifactDir, targetFileName)
                        if (!targetFile.exists()) {
                            logger.lifecycle "üì¶ Copying buildSrc artifact: ${group}:${name}:${version}"
                            project.copy {
                                from artifactFile
                                into artifactDir
                            }
                            buildSrcArtifacts++
                            
                            // Copy additional artifacts (POM, sources, javadoc)
                            resolveAndCopyAdditionalArtifacts(group, name, version, artifactDir)
                        }
                    }
                } catch (Exception e) {
                    logger.warn "Warning: Could not resolve buildSrc configuration ${configuration.name}: ${e.message}"
                }
            }
        }
        
    } catch (Exception e) {
        logger.warn "Warning: Could not process buildSrc dependencies: ${e.message}"
    }
    
    return buildSrcArtifacts
}

// Recursively resolve parent POMs
def resolveParentPomsRecursively() {
    def resolvedParents = 0
    def processedParents = new HashSet()
    def parentsToProcess = new LinkedHashSet()
    
    // Find all existing POM files and extract parent references
    logger.lifecycle "üì¶ Scanning existing POMs for parent references..."
    def localRepoDir = file(localRepoPath)
    localRepoDir.eachFileRecurse { file ->
        if (file.name.endsWith('.pom')) {
            def parentRef = extractParentPomReference(file)
            if (parentRef && !processedParents.contains(parentRef)) {
                parentsToProcess.add(parentRef)
                logger.lifecycle "üîó Found parent reference: ${parentRef} in ${file.name}"
            }
        }
    }
    
    // Recursively resolve parent POMs
    while (!parentsToProcess.isEmpty()) {
        def currentParents = new ArrayList(parentsToProcess)
        parentsToProcess.clear()
        
        currentParents.each { parentCoords ->
            if (!processedParents.contains(parentCoords)) {
                processedParents.add(parentCoords)
                
                def coords = parentCoords.split(':')
                if (coords.length >= 3) {
                    def group = coords[0]
                    def artifact = coords[1]
                    def version = coords[2]
                    
                    logger.lifecycle "üì¶ Resolving parent POM: ${parentCoords}"
                    
                    try {
                        def parentDir = getMavenArtifactPath(group, artifact, version)
                        def parentPomFile = new File(parentDir, "${artifact}-${version}.pom")
                        
                        if (!parentPomFile.exists()) {
                            // Try to resolve the parent POM
                            def depConf = configurations.detachedConfiguration()
                            def dependency = dependencies.create("${group}:${artifact}:${version}@pom")
                            depConf.dependencies.add(dependency)
                            
                            def resolved = depConf.resolve()
                            if (!resolved.isEmpty()) {
                                if (!parentDir.exists() && !parentDir.mkdirs()) {
                                    throw new GradleException("Failed to create directory: $parentDir")
                                }
                                
                                resolved.each { file ->
                                    def targetFile = new File(parentDir, "${artifact}-${version}.pom")
                                    logger.lifecycle "üì¶ Copying parent POM: ${file.name} -> ${targetFile.name}"
                                    project.copy {
                                        from file
                                        into parentDir
                                        rename { fileName -> "${artifact}-${version}.pom" }
                                    }
                                    resolvedParents++
                                    
                                    // Check if this parent POM has its own parent
                                    def grandParentRef = extractParentPomReference(targetFile)
                                    if (grandParentRef && !processedParents.contains(grandParentRef)) {
                                        parentsToProcess.add(grandParentRef)
                                        logger.lifecycle "üîó Found grandparent reference: ${grandParentRef}"
                                    }
                                }
                            }
                        } else {
                            logger.lifecycle "üì¶ Parent POM already exists: ${parentPomFile.name}"
                        }
                        
                    } catch (Exception e) {
                        logger.warn "Warning: Could not resolve parent POM ${parentCoords}: ${e.message}"
                    }
                }
            }
        }
    }
    
    return resolvedParents
}

// Helper method to resolve artifacts using Gradle's variant-aware dependency resolution
def resolveVariantArtifacts(String group, String name, String version, File artifactDir, String type) {
    try {
        def conf = configurations.detachedConfiguration()
        conf.attributes {
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            if (type == 'sources') {
                attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
            } else if (type == 'javadoc') {
                attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.JAVADOC))
            }
        }

        conf.dependencies.add(dependencies.create("${group}:${name}:${version}"))

        conf.resolve().each { file ->
            def target = new File(artifactDir, file.name)
            if (!target.exists()) {
                logger.info "Copying ${type} artifact: $file to $target"
                project.copy {
                    from file
                    into artifactDir
                }
                if (target.exists() && target.length() > 0) {
                    logger.info "Successfully copied ${type}: ${file.name} (${target.length()} bytes)"
                }
            }
        }
    } catch (Exception e) {
        logger.debug "Variant-aware resolution failed for ${group}:${name}:${version} ${type}: ${e.message}"
    }
}

// Resolve known plugin runtime dependencies that may be created dynamically
def resolvePluginRuntimeDependencies() {
    def resolvedRuntimeDeps = 0
    
    try {
        // Dynamically determine manifold version from actual project resolution
        def manifoldVersion = getResolvedManifoldVersion()
        if (!manifoldVersion) {
            logger.lifecycle "üì¶ No manifold version found in project dependencies, skipping plugin runtime dependencies"
            return 0
        }
        
        logger.lifecycle "üì¶ Using manifold version: ${manifoldVersion} (from project dependencies)"
        
        // Known Gosu plugin runtime dependencies that it resolves dynamically
        def gosuPluginDeps = [
            "systems.manifold:manifold:${manifoldVersion}",
            "systems.manifold:manifold-rt:${manifoldVersion}",
            "systems.manifold:manifold-util:${manifoldVersion}",
            // Core manifold API that contains IManifoldHost
            "systems.manifold:manifold-api:${manifoldVersion}",
            // Additional manifold dependencies that contain required classes
            "systems.manifold:manifold-collections:${manifoldVersion}",
            "systems.manifold:manifold-ext:${manifoldVersion}",
            "systems.manifold:manifold-io:${manifoldVersion}",
            "systems.manifold:manifold-json:${manifoldVersion}",
            "systems.manifold:manifold-props:${manifoldVersion}",
            "systems.manifold:manifold-strings:${manifoldVersion}",
            "systems.manifold:manifold-templates:${manifoldVersion}"
        ]
        
        logger.lifecycle "üì¶ Resolving known Gosu plugin runtime dependencies..."
        
        gosuPluginDeps.each { depCoords ->
            try {
                def coords = depCoords.split(':')
                def group = coords[0]
                def artifact = coords[1]
                def version = coords[2]
                
                def artifactDir = getMavenArtifactPath(group, artifact, version)
                def targetFile = new File(artifactDir, "${artifact}-${version}.jar")
                
                if (!targetFile.exists()) {
                    logger.lifecycle "üì¶ Resolving plugin runtime dependency: ${depCoords}"
                    
                    def depConf = configurations.detachedConfiguration()
                    def dependency = dependencies.create(depCoords)
                    depConf.dependencies.add(dependency)
                    
                    def resolved = depConf.resolve()
                    if (!resolved.isEmpty()) {
                        if (!artifactDir.exists() && !artifactDir.mkdirs()) {
                            throw new GradleException("Failed to create directory: $artifactDir")
                        }
                        
                        // Only copy files that actually match the requested artifact
                        resolved.each { file ->
                            // Only copy if filename matches the expected artifact pattern
                            if (file.name.startsWith("${artifact}-${version}")) {
                                def targetName = file.name
                                def target = new File(artifactDir, targetName)
                                logger.lifecycle "üì¶ Copying plugin runtime dependency: ${file.name} -> ${targetName}"
                                project.copy {
                                    from file
                                    into artifactDir
                                }
                                resolvedRuntimeDeps++
                                
                                // Note: Not calling resolveAndCopyAdditionalArtifacts here to avoid
                                // transitive dependency pollution in artifact directories
                                // Each plugin dependency is resolved individually in the loop
                            } else {
                                logger.debug "Skipping transitive dependency file: ${file.name} (not main artifact for ${artifact})"
                            }
                        }
                    }
                } else {
                    logger.lifecycle "üì¶ Plugin runtime dependency already exists: ${targetFile.name}"
                }
                
            } catch (Exception e) {
                logger.warn "Warning: Could not resolve plugin runtime dependency ${depCoords}: ${e.message}"
            }
        }
        
    } catch (Exception e) {
        logger.warn "Warning: Could not process plugin runtime dependencies: ${e.message}"
    }
    
    return resolvedRuntimeDeps
}

// Helper method to get the resolved manifold version from project dependencies
def getResolvedManifoldVersion() {
    try {
        // Look through all resolved configurations for manifold dependencies
        def manifoldVersion = null
        configurations.findAll { it.canBeResolved }.each { configuration ->
            try {
                configuration.resolvedConfiguration.resolvedArtifacts.each { artifact ->
                    if (artifact.moduleVersion.id.group == 'systems.manifold' &&
                        artifact.moduleVersion.id.name == 'manifold') {
                        manifoldVersion = artifact.moduleVersion.id.version
                        logger.debug "Found manifold version ${manifoldVersion} in configuration ${configuration.name}"
                    }
                }
            } catch (Exception e) {
                // Ignore configuration resolution errors
            }
        }
        return manifoldVersion
    } catch (Exception e) {
        logger.warn "Could not determine manifold version: ${e.message}"
        return null
    }
}

ext.localRepoPath = localRepoPath
